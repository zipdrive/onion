// Fragment shader
#version 330 core

#define NR_CUBE_LIGHTS 8


in VS_FS
{
    // The fragment position
    vec2 pos;

    // The UV texture coordinates
    vec2 uv;
}
fs_in;



struct CubeLight
{
    // The corner with minimum values.
    vec3 mins;
    
    // The corner with maximum values.
    vec3 maxs;
    
    
    // The color of the light.
    vec3 color;
    
    // The intensity of the specular highlight.
    float intensity;
    
    
    // The maximum radius of the light.
    float radius;
};

vec3 CalcCubeLight(CubeLight light, vec2 pos, sampler2D noiseTexture)
{
    // Calculate the closest point on the light
    vec3 closest = vec3(
        max(light.mins.x, min(light.maxs.x, pos.x)),
        max(light.mins.y, min(light.maxs.y, pos.y)),
        max(light.mins.z, min(light.maxs.z, 0.0))
    );
    vec3 dir = closest - vec3(pos, 0.0);
    
    float maxDistance = sqrt((light.radius * light.radius) - (closest.z * closest.z)); // The maximum distance from the closest point
    
    float distance = length(dir);
    if (distance < maxDistance)
    {
        float maxStrength = 1.0 + light.intensity; // The strength of the light directly underneath the closest point
        
        // Calculate the base strength of the light
        float leveledStrength = maxStrength * max(1.0 - pow(distance / maxDistance, 0.9), 0.0);
        //float diffuseStrength = dir.z / distance;
        float baseStrength = leveledStrength;
        
        // Calculate the discretized strength of the light
        float strengthPerLevel = maxStrength / round(5.0 * maxStrength);
        float strength = strengthPerLevel * round(baseStrength / strengthPerLevel);
        
        // Dither the boundary between discrete strengths
        float closenessToBoundary = (strength - baseStrength) / strengthPerLevel;
        float strengthChange = -strengthPerLevel;
        if (closenessToBoundary < 0.0)
        {
            closenessToBoundary += 1.0;
            strengthChange = -strengthChange;
        }
        float dither = texture(noiseTexture, vec2(closenessToBoundary, 0.03125 * dot(vec2(2.0, 19.0), pos))).r;
        strength += (dither * min(strengthChange, 0.0)) + ((1.0 - dither) * max(strengthChange, 0.0));
        
        return strength * light.color;
    }
    
    return vec3(0.0);
}


uniform Lighting
{
    // The ambient light
    vec3 ambient;
    
    // All lights shaped like a rectangular prism
    CubeLight cubeLights[NR_CUBE_LIGHTS];
    int numCubeLights;
};



uniform sampler2D tileTexture;
uniform sampler2D noiseTexture;


// MAIN FUNCTION

#define AddCubeLightColor(k)        if (k < numCubeLights) color += CalcCubeLight(cubeLights[k], fs_in.pos, noiseTexture)

void main()
{
    vec3 diff = vec3(texture(tileTexture, fs_in.uv));
    vec3 color = ambient;
    
    // This is SUCH a hacky solution, but I have a driver bug or something that apparently doesn't like for loops? So whatever.
    AddCubeLightColor(0);
    AddCubeLightColor(1);
    AddCubeLightColor(2);
    AddCubeLightColor(3);
    AddCubeLightColor(4);
    AddCubeLightColor(5);
    AddCubeLightColor(6);
    AddCubeLightColor(7);
    
    gl_FragColor = vec4(color * diff, 1.0);
}