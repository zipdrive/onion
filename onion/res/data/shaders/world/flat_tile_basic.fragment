// Fragment shader
#version 330 core

#define NR_CUBE_LIGHTS 8


in VS_FS
{
    // The fragment position
    vec2 pos;

    // The UV texture coordinates
    vec2 uv;
}
fs_in;



struct CubeLight
{
    // The corner with minimum values
    vec3 mins;
    
    // The corner with maximum values
    vec3 maxs;
    
    
    // The diffuse color of the light
    vec3 diffuse;
    
    // The specular color of the light
    vec3 specular;
    
    
    // Attenuation variables
    float constant;
    float linear;
    float quadratic;
};

vec3 CalcCubeLight(CubeLight light, vec2 pos, vec3 color)
{
    vec3 dir = vec3(
        max(light.mins.x - pos.x, min(light.maxs.x - pos.x, 0.0)),
        max(light.mins.y - pos.y, min(light.maxs.y - pos.y, 0.0)),
        max(light.mins.z, min(light.maxs.z, 0.0))
    );
    
    // The strength of diffuse shading
    vec3 dir_n = normalize(dir);
    float diff = max(dir_n.z, 0.0);
    vec3 diffuseColor = diff * light.diffuse;
    
    // The strength of specular shading
    vec3 half_n = normalize(vec3(0.0, 0.0, 1.0) + dir_n);
    float spec = pow(max(half_n.z, 0.0), 8);
    vec3 specularColor = spec * light.specular;
    
    // The attenuation of the light
    float dist = length(dir);
    float attenuation = 1.0 / (light.constant + ((light.linear + (light.quadratic * dist)) * dist));
    
    return attenuation * (diffuseColor + specularColor) * color;
}


uniform Lighting
{
    // The ambient light
    vec3 ambient;
    
    // All lights shaped like a rectangular prism
    CubeLight cubeLights[NR_CUBE_LIGHTS];
    int numCubeLights;
};



uniform sampler2D tileTexture;
//uniform sampler2D noiseTexture;


// MAIN FUNCTION

void main()
{
    vec3 diff = vec3(texture(tileTexture, fs_in.uv));
    vec3 color = ambient * diff;
    
    for (int k = 0; k < numCubeLights; k++)
        color += CalcCubeLight(cubeLights[k], fs_in.pos, diff);
    
    gl_FragColor = vec4(color, 1.0);
}