#pragma once
#include "../graphics/sprite.h"
#include "geometry.h"

namespace onion
{
	namespace world
	{

		// A three-dimensional graphic displayed to the screen.
		class Graphic3D
		{
		public:
			/// <summary>Displays the graphic.</summary>
			/// <param name="normal">A vector pointing towards the camera.</param>
			virtual void display(const vec3i& normal) const = 0;
		};


		// A sprite sheet that uses dither shading with a normal vector interpolated from each vertex.
		class Flat3DPixelSpriteSheet : public PixelSpriteSheet<Int, Int>
		{
		protected:
			// The shader program for the sprite sheet.
			static _SpriteShader* m_Flat3DPixelShader;

			/// <summary>Loads vertex attribute data from a line in a meta file.</summary>
			/// <param name="id">The ID associated with the line of data.</param>
			/// <param name="line">The line of data from the meta file.</param>
			/// <param name="image">The loaded image.</param>
			/// <param name="data">Outputs the vertex attributes into this array of numeric data.</param>
			/// <returns>The sprite generated by the line of data.</returns>
			opengl::_VertexBufferData* __load(LoadFile& file, opengl::_Image* image);

		public:
			/// <summary>Gets the shader for pixel perfect sprites.</summary>
			/// <returns>A shader that only takes two image keys as arguments.</returns>
			static _SpriteShader* get_shader();

			/// <summary>Loads a sprite sheet from file.</summary>
			/// <param name="path">The path to the image file, from the res/img/world/ folder.</param>
			Flat3DPixelSpriteSheet(const char* path);

			
			using PixelSpriteSheet<Int, Int>::display;

			/// <summary>Displays a sprite from the sprite sheet.</summary>
			/// <param name="sprite">The sprite to display.</param>
			virtual void display(const Sprite* sprite) const;
		};

		// A sprite shader that does NOT use dither shading, that samples a normal vector from an image.
		class Textured3DPixelSpriteSheet : public PixelSpriteSheet<FLOAT_MAT4X2, FLOAT_MAT4, Int>
		{
		protected:
			// The shader program for the sprite sheet.
			static _SpriteShader* m_Textured3DPixelShader;

			// Manages the textures on the sprite sheet.
			_TextureManager m_TextureManager;

			/// <summary>Loads vertex attribute data from a line in a meta file.</summary>
			/// <param name="id">The ID associated with the line of data.</param>
			/// <param name="line">The line of data from the meta file.</param>
			/// <param name="image">The loaded image.</param>
			/// <param name="data">Outputs the vertex attributes into this array of numeric data.</param>
			/// <returns>The sprite generated by the line of data.</returns>
			opengl::_VertexBufferData* __load(LoadFile& file, opengl::_Image* image);

		public:
			/// <summary>Gets the shader for pixel perfect sprites.</summary>
			/// <returns>A shader that only takes two image keys as arguments.</returns>
			static _SpriteShader* get_shader();

			/// <summary>Loads a sprite sheet from file.</summary>
			/// <param name="path">The path to the image file, from the res/img/world/ folder.</param>
			Textured3DPixelSpriteSheet(const char* path);


			/// <summary>Retrieves the sprite associated with the given ID.</summary>
			/// <param name="id">The ID to retrieve the sprite of.</param>
			/// <returns>The sprite associated with the ID, if there is one. NULL otherwise.</returns>
			Texture* get_texture(TEXTURE_ID id);
			
			/// <summary>Retrieves the sprite associated with the given ID.</summary>
			/// <param name="id">The ID to retrieve the sprite of.</param>
			/// <returns>The sprite associated with the ID, if there is one. NULL otherwise.</returns>
			const Texture* get_texture(TEXTURE_ID id) const;


			using PixelSpriteSheet<FLOAT_MAT4X2, FLOAT_MAT4, Int>::display;

			/// <summary>Displays a sprite from the sprite sheet.</summary>
			/// <param name="sprite">The sprite to display.</param>
			/// <param name="flip_horizontally">True if the sprite should be flipped horizontally, false if not.</param>
			/// <param name="texture">The texture to color the sprite with.</param>
			/// <param name="palette">The color palette to display the sprite with.</param>
			virtual void display(const Sprite* sprite, bool flip_horizontally, const Texture* texture, const Palette* palette) const;
		};


		// 
		class Shaded3DPixelSpriteSheet : public PixelSpriteSheet<FLOAT_MAT4X2, FLOAT_MAT4, Int>
		{
		protected:
			// The shader program for the sprite sheet.
			static _SpriteShader* m_Shaded3DPixelShader;

			// Manages the textures on the sprite sheet.
			_TextureManager m_TextureManager;

			/// <summary>Loads vertex attribute data from a line in a meta file.</summary>
			/// <param name="id">The ID associated with the line of data.</param>
			/// <param name="line">The line of data from the meta file.</param>
			/// <param name="image">The loaded image.</param>
			/// <param name="data">Outputs the vertex attributes into this array of numeric data.</param>
			/// <returns>The sprite generated by the line of data.</returns>
			opengl::_VertexBufferData* __load(LoadFile& file, opengl::_Image* image);

		public:
			/// <summary>Gets the shader for pixel perfect sprites.</summary>
			/// <returns>A shader that only takes two image keys as arguments.</returns>
			static _SpriteShader* get_shader();

			/// <summary>Loads a sprite sheet from file.</summary>
			/// <param name="path">The path to the image file, from the res/img/world/ folder.</param>
			Shaded3DPixelSpriteSheet(const char* path);


			/// <summary>Retrieves the sprite associated with the given ID.</summary>
			/// <param name="id">The ID to retrieve the sprite of.</param>
			/// <returns>The sprite associated with the ID, if there is one. NULL otherwise.</returns>
			Texture* get_texture(TEXTURE_ID id);

			/// <summary>Retrieves the sprite associated with the given ID.</summary>
			/// <param name="id">The ID to retrieve the sprite of.</param>
			/// <returns>The sprite associated with the ID, if there is one. NULL otherwise.</returns>
			const Texture* get_texture(TEXTURE_ID id) const;


			using PixelSpriteSheet<FLOAT_MAT4X2, FLOAT_MAT4, Int>::display;

			/// <summary>Displays a sprite from the sprite sheet.</summary>
			/// <param name="sprite">The sprite to display.</param>
			/// <param name="flip_horizontally">True if the sprite should be flipped horizontally, false if not.</param>
			/// <param name="texture">The texture to color the sprite with.</param>
			/// <param name="palette">The color palette to display the sprite with.</param>
			virtual void display(const Sprite* sprite, bool flip_horizontally, const Texture* texture, const Palette* palette) const;
		};


		
		// A three-dimensional graphic that uses sprites from a sprite sheet.
		template <typename T>
		class SpriteGraphic3D : public Graphic3D
		{
		protected:
			// The sprite sheet that the sprite is on.
			const T* m_SpriteSheet;

		public:
			/// <summary>Constructs a three-dimensional sprite graphic.</summary>
			/// <param name="sprite_sheet">The sprite sheet that the sprite is on.</param>
			SpriteGraphic3D(const T* sprite_sheet) : m_SpriteSheet(sprite_sheet) {}
		};


		// A graphic used to display a dimensionless wall aligned with the x-axis.
		class FlatWallGraphic3D : public SpriteGraphic3D<Flat3DPixelSpriteSheet>
		{
		protected:
			// The sprite to use for the wall.
			const Sprite* m_Sprite;

		public:
			/// <summary>Constructs a dimensionless wall graphic.</summary>
			/// <param name="sprite_sheet">The sprite sheet that the sprite is on.</param>
			/// <param name="sprite">The ID of the sprite to use when displaying the wall.</param>
			FlatWallGraphic3D(const Flat3DPixelSpriteSheet* sprite_sheet, const Sprite* sprite);

			/// <summary>Displays the wall.</summary>
			/// <param name="normal">A vector pointing towards the camera.</param>
			virtual void display(const vec3i& normal) const;
		};

		// A wall sprite with an arbitrary two-dimensional normal vector.
		class TransformedFlatWallGraphic3D : public FlatWallGraphic3D
		{
		protected:
			// The transform matrix.
			TransformMatrix m_Transform;

		public:
			/// <summary>Constructs a dimensionless wall graphic whose transformation is defined by the scaling factor of the wall on each axis.
			/// Should primarily be used for graphics intended to be viewed from a fixed angle.</summary>
			/// <param name="sprite_sheet">The sprite sheet that the sprite is on.</param>
			/// <param name="sprite">The ID of the sprite to use when displaying the wall.</param>
			/// <param name="scale">The scale factor for each axis. A scale factor of 0 means the wall will be displayed perpendicular to that axis.</param>
			TransformedFlatWallGraphic3D(const Flat3DPixelSpriteSheet* sprite_sheet, const Sprite* sprite, const vec2f& scale);
			
			/// <summary>Constructs a dimensionless wall graphic transformed by a rotation around the z-axis.</summary>
			/// <param name="sprite_sheet">The sprite sheet that the sprite is on.</param>
			/// <param name="sprite">The ID of the sprite to use when displaying the wall.</param>
			/// <param name="angle">The angle of rotation around the z-axis, in radians.</param>
			TransformedFlatWallGraphic3D(const Flat3DPixelSpriteSheet* sprite_sheet, const Sprite* sprite, Float angle);

			/// <summary>Displays the wall.</summary>
			/// <param name="normal">A vector pointing towards the camera.</param>
			virtual void display(const vec3i& normal) const;
		};


		// A textured sprite graphic that uses the same texture but different sprites for shading.
		class DynamicShadingSpriteGraphic3D : public SpriteGraphic3D<Textured3DPixelSpriteSheet>
		{
		protected:
			// The sprites for shading.
			std::vector<const Sprite*> m_Sprites;

			// The index of the current sprite to display.
			int m_SpriteIndex;

			// True if the sprite should be flipped horizontally, false otherwise.
			bool m_FlipHorizontally;

			// The texture to use.
			const Texture* m_Texture;

			// The palette to use.
			Palette* m_Palette;

		public:
			/// <summary>Constructs a textured sprite graphic with one texture and multiple sprites.</summary>
			/// <param name="sprite_sheet">The sprite sheet that the sprite is on.</param>
			/// <param name="sprites">All sprites that the graphic can use.</param>
			/// <param name="flip_horizontally">True if the sprite should be flipped horizontally, false otherwise.</param>
			/// <param name="texture">The texture to use when displaying the graphic.</param>
			/// <param name="palette">The palette to use when displaying the graphic.</param>
			DynamicShadingSpriteGraphic3D(const Textured3DPixelSpriteSheet* sprite_sheet, const std::vector<const Sprite*>& sprites, bool flip_horizontally, const Texture* texture, Palette* palette);

			/// <summary>Displays the sprite using the current index.</summary>
			/// <param name="normal">A vector pointing towards the camera.</param>
			virtual void display(const vec3i& normal) const;
		};



		// A three-dimensional graphic that is always rotated so it faces the screen.
		template <typename T>
		class _BillboardedGraphic3D : public T
		{
		public:
			/// <summary>Constructs a graphic that always faces towards the screen.</summary>
			template <typename... _Args>
			_BillboardedGraphic3D(const _Args&... args) : T(args...) {}

			/// <summary>Displays the graphic as facing towards the screen.</summary>
			/// <param name="normal">A vector pointing towards the camera.</param>
			virtual void display(const vec3i& normal) const
			{
				// Set up the transform
				Transform::model.push();

				// Pivot the sprite so that dir => (0, -1)
				Int x = normal.get(0), y = normal.get(1);
				Float len = sqrtf((x * x) + (y * y));
				Float c = -y / len;
				Float s = x / len;

				Transform::model.custom(
					TransformMatrix(
						c, -s, 0.f, 0.f,
						s,  c
					)
				);

				// Display the graphic
				T::display(normal);

				// Clean up
				Transform::model.pop();
			}
		};

		typedef _BillboardedGraphic3D<FlatWallGraphic3D> BillboardedFlatWallGraphic3D;

	}
}